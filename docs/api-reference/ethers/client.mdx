---
title: EthersClient
description: Low-level client that carries providers/signer, resolves core contract addresses, and exposes convenience contract instances for the Ethers adapter.
group: API Reference / Ethers
---

## Import

```ts
import {
  createEthersClient,
} from '@dutterbutter/zksync-sdk/ethers';
```

## Quick start

```ts
import { JsonRpcProvider, Wallet } from 'ethers';
import { createEthersClient } from '@dutterbutter/zksync-sdk/ethers';

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });

// Resolve core addresses once (cached)
const addrs = await client.ensureAddresses();

// Grab connected Contract instances
const { bridgehub, l1AssetRouter } = await client.contracts();
```

## `createEthersClient(args) → EthersClient`

<ParamField name="args.l1" type="ethers.AbstractProvider" required>
  L1 provider used for address resolution and L1 transactions.
</ParamField>
<ParamField name="args.l2" type="ethers.AbstractProvider" required>
  L2 provider (target ZK chain). Used for ZK RPC and reads.
</ParamField>
<ParamField name="args.signer" type="ethers.Signer" required>
  Signer used for sends. If not already connected to <code>args.l1</code>, it will be connected.
</ParamField>
<ParamField name="args.overrides" type="Partial&lt;ResolvedAddresses&gt;">
  Optional manual contract-address overrides (useful for forks or testing).
</ParamField>

<Tip>
  The signer is force-bound to the L1 provider to ensure finalize transactions work out of the box.
</Tip>

## EthersClient interface

<ResponseField name="kind" type="'ethers'">
  Discriminator for the adapter.
</ResponseField>
<ResponseField name="l1" type="ethers.AbstractProvider">
  Read/write L1 provider.
</ResponseField>
<ResponseField name="l2" type="ethers.AbstractProvider">
  Read-only L2 provider (target ZK chain).
</ResponseField>
<ResponseField name="signer" type="ethers.Signer">
  Signer used for sends; connected to <code>l1</code>.
</ResponseField>
<ResponseField name="zks" type="ZksRpc">
  ZKsync-specific RPC surface bound to <code>l2</code>.
</ResponseField>

### Methods

#### `ensureAddresses() → Promise<ResolvedAddresses>`

Resolves and caches core contract addresses via on-chain lookups (and optional overrides).

```ts
const a = await client.ensureAddresses();
/*
a = {
  bridgehub, l1AssetRouter, l1Nullifier, l1NativeTokenVault,
  l2AssetRouter, l2NativeTokenVault, l2BaseTokenSystem
}
*/
```

#### `contracts() → Promise<{ ...contracts }>`

Returns connected `ethers.Contract` instances for all core contracts.

```ts
const c = await client.contracts();
const bh = c.bridgehub;
```

#### `refresh(): void`

Clears cached addresses/contracts. Next calls will re-resolve.

```ts
client.refresh();
await client.ensureAddresses(); // re-fetches
```

#### `baseToken(chainId: bigint) → Promise<Address>`

Looks up the **L1 address** of the base token for a given L2 chain via `Bridgehub.baseToken(chainId)`.

```ts
const base = await client.baseToken( BigInt(324) /* ZKsync Era */ );
```

## Types

### `ResolvedAddresses`

```ts
type ResolvedAddresses = {
  bridgehub: Address;
  l1AssetRouter: Address;
  l1Nullifier: Address;
  l1NativeTokenVault: Address;
  l2AssetRouter: Address;
  l2NativeTokenVault: Address;
  l2BaseTokenSystem: Address;
};
```
