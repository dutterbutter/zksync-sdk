---
title: Deposits
description: L1 → L2 deposits for ETH and ERC-20 with quote, prepare, create, status, and wait helpers.
group: API Reference / Ethers
---

## Import

The Deposits resource is available via the Ethers SDK:

```ts
import { JsonRpcProvider, Wallet, parseEther } from "ethers";
import { createEthersClient, createEthersSdk } from "@dutterbutter/zksync-sdk/ethers";

const l1 = new JsonRpcProvider(process.env.ETH_RPC!);
const l2 = new JsonRpcProvider(process.env.ZKSYNC_RPC!);
const signer = new Wallet(process.env.PRIVATE_KEY!, l1);

const client = createEthersClient({ l1, l2, signer });
const sdk = createEthersSdk(client);
// sdk.deposits → DepositsResource
```

## Quick start

Deposit **0.1 ETH** from L1 → L2 and wait for **L2 execution**:

```ts
const handle = await sdk.deposits.create({
  token: ETH_ADDRESS,
  amount: parseEther("0.1"),
  to: await signer.getAddress(),
});

// Wait for canonical L2 execution; returns L2 receipt or null
const l2Receipt = await sdk.deposits.wait(handle, { for: "l2" });
```

## Routes (auto-selected)

The SDK automatically selects a route based on the **asset** and the **L2 base token**:

* `eth-base` — Deposit ETH when L2 base token is **ETH**
* `eth-nonbase` — Deposit ETH when L2 base token is **not ETH**
* `erc20-base` — Deposit ERC-20 that **is** the L2 base token
* `erc20-nonbase` — Deposit ERC-20 that **is not** the L2 base token

You don’t need to pass a route; it’s derived internally.

## Methods

### `quote(p: DepositParams) → Promise<DepositQuote>`

Get a **non-executing** summary of the deposit (route, approvals, gas hints).

<ParamField name="p.token" type="Address" required>
  L1 token address (use <code>0x…00</code> for ETH).
</ParamField>
<ParamField name="p.amount" type="bigint" required>
  Amount in wei.
</ParamField>
<ParamField name="p.to" type="Address" required>
  Recipient on L2.
</ParamField>

```ts
const q = await sdk.deposits.quote({
  token: ETH_L1,
  amount: parseEther("0.25"),
  to: await signer.getAddress(),
});
/*
q = {
  route: "eth-base" | "eth-nonbase" | "erc20-base" | "erc20-nonbase",
  approvalsNeeded: [{ token, spender, amount }, ...],
  baseCost,            // bigint (bridge/base cost estimate if applicable)
  mintValue,           // bigint (if applicable on route)
  suggestedL2GasLimit, // bigint
  gasPerPubdata        // bigint
}
*/
```

<Tip>
  If <code>approvalsNeeded</code> is non-empty for ERC-20 deposits, the SDK will include
  approval steps during <code>create</code>. These are approved automatically.
</Tip>

### `tryQuote(p) → Promise<{ ok: true; value: DepositQuote } | { ok: false; error }>;`

Result-style version of `quote`.

### `prepare(p: DepositParams) → Promise<DepositPlan<TransactionRequest>>`

Build the **plan** (route + ordered steps) without sending transactions.

```ts
const plan = await sdk.deposits.prepare({ token: ETH_L1, amount: parseEther("0.05"), to });
/*
plan = {
  route,
  summary: { ...same shape as DepositQuote },
  steps: [
    // Each step has a unique .key, a .kind (e.g., "approve" | "bridge"),
    // and a prebuilt ethers TransactionRequest in .tx
  ]
}
*/
```

### `tryPrepare(p) → Promise<{ ok: true; value: DepositPlan } | { ok: false; error }>;`

Result-style version of `prepare`.

### `create(p: DepositParams) → Promise<DepositHandle<TransactionRequest>>`

Prepare and **execute** all required steps on **L1**. Returns a handle with the L1 hash.

```ts
const handle = await sdk.deposits.create({ token, amount, to });
/*
handle = {
  kind: "deposit",
  l1TxHash,                  // Hex
  stepHashes: Record<string, Hex>, // tx hashes per step
  plan                       // DepositPlan returned by prepare()
}
*/
```

<Warning>
  If any step reverts on L1, <code>create</code> throws a typed error.
  Use <code>tryCreate</code> if you prefer a result object.
</Warning>

### `tryCreate(p) → Promise<{ ok: true; value: DepositHandle } | { ok: false; error }>;`

Result-style version of `create`.

### `status(h | l1TxHash) → Promise<DepositStatus>`

Check a deposit’s current phase. Accepts the **handle** from `create` or a raw **L1 tx hash**.

Phases:

* `UNKNOWN` — no L1 hash on input
* `L1_PENDING` — L1 receipt not found yet
* `L1_INCLUDED` — included on L1 but L2 hash not yet derivable
* `L2_PENDING` — L2 hash known but L2 receipt missing
* `L2_EXECUTED` — L2 receipt found with `status === 1`
* `L2_FAILED` — L2 receipt found with `status !== 1`

```ts
const s = await sdk.deposits.status(handle);
/*
s = { phase, l1TxHash, l2TxHash? }
*/
```

### `wait(h | l1TxHash, { for: 'l1' | 'l2' }) → Promise<TransactionReceipt | null>`

Block until a checkpoint:

* `{ for: 'l1' }` → resolves the **L1 receipt** (or `null` if no L1 hash on input)
* `{ for: 'l2' }` → resolves the **L2 receipt** after canonical execution (or `null` if no L1 hash)

```ts
const l1Receipt = await sdk.deposits.wait(handle, { for: "l1" });
const l2Receipt = await sdk.deposits.wait(handle, { for: "l2" });
```

### `tryWait(h, { for }) → Promise<{ ok: true; value: TransactionReceipt } | { ok: false; error }>;`

Result-style version of `wait`.

## End-to-end examples

### ETH deposit (most common)

```ts
const handle = await sdk.deposits.create({
  token: ETH_ADDRESS,
  amount: parseEther("0.1"),
  to: await signer.getAddress(),
});

await sdk.deposits.wait(handle, { for: "l2" }); // get L2 receipt when executed
```

### ERC-20 deposit with approvals

```ts
const handle = await sdk.deposits.create({
  token: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // example ERC-20
  amount: 1000000n, // 1e6 (USDC 6 decimals)
  to: await signer.getAddress(),
});

// Wait for L1 inclusion only, if you need to chain logic at that point
const l1Receipt = await sdk.deposits.wait(handle, { for: "l1" });
```

## Types (shape overview)

These types live in `core/types` and are summarized here for convenience.

```ts
type DepositParams = {
  token: Address;      // L1 token (0x…00 for ETH)
  amount: bigint;      // in wei
  to: Address;         // L2 recipient
  // ...additional fields may exist; see core/types for the full spec
};

type DepositQuote = {
  route: "eth-base" | "eth-nonbase" | "erc20-base" | "erc20-nonbase";
  approvalsNeeded: Array<{ token: Address; spender: Address; amount: bigint }>;
  baseCost?: bigint;
  mintValue?: bigint;
  suggestedL2GasLimit?: bigint;
  gasPerPubdata?: bigint;
};

type DepositPlan<TTx = TransactionRequest> = {
  route: DepositQuote["route"];
  summary: DepositQuote;
  steps: Array<{ key: string; kind: string; tx: TTx }>;
};

type DepositHandle<TTx = TransactionRequest> = {
  kind: "deposit";
  l1TxHash: Hex;
  stepHashes: Record<string, Hex>;
  plan: DepositPlan<TTx>;
};

type DepositStatus =
  | { phase: "UNKNOWN";      l1TxHash: Hex }
  | { phase: "L1_PENDING";   l1TxHash: Hex }
  | { phase: "L1_INCLUDED";  l1TxHash: Hex }
  | { phase: "L2_PENDING";   l1TxHash: Hex; l2TxHash: Hex }
  | { phase: "L2_EXECUTED";  l1TxHash: Hex; l2TxHash: Hex }
  | { phase: "L2_FAILED";    l1TxHash: Hex; l2TxHash: Hex };
```

<Tip>
  Prefer the <code>try*</code> variants if you want to avoid exceptions and work with result objects.
</Tip>

