---
title: ViemSdk
description: High-level SDK for deposits, withdrawals, and helpers using the Viem adapter.
group: API Reference / Viem
---

## Import

```ts
import {
  createViemClient,
  createViemSdk,
} from '@dutterbutter/zksync-sdk/viem';
```

## Quick start

```ts
import { createPublicClient, createWalletClient, http } from 'viem';
import { createViemClient, createViemSdk } from '@dutterbutter/zksync-sdk/viem';

// Provide your chain objects & RPC URLs as needed
const l1 = createPublicClient({ transport: http(process.env.ETH_RPC!) });
const l2 = createPublicClient({ transport: http(process.env.ZKSYNC_RPC!) });

const l1Wallet = createWalletClient({
  account: /* your Account */,
  transport: http(process.env.ETH_RPC!),
});

// (optional) pass an L2 wallet; needed during withdrawals to finalize
const l2Wallet = createWalletClient({
  account: l1Wallet.account,
  transport: http(process.env.ZKSYNC_RPC!),
});

const client = createViemClient({ l1, l2, l1Wallet, l2Wallet });
const sdk = createViemSdk(client);

// Example: get contracts and the L2 address for an L1 token
const { l1NativeTokenVault } = await sdk.helpers.contracts();
const l2_crown_address = await sdk.helpers.l2TokenAddress(CROWN_ERC20_ADDRESS);
```

<Tip>
  The SDK composes the Viem client with high-level resources: <code>deposits</code>, <code>withdrawals</code>, and convenience <code>helpers</code>.
</Tip>

## `createViemSdk(client) → ViemSdk`

<ParamField name="client" type="ViemClient" required>
  Instance created by <code>createViemClient</code>.
</ParamField>

## ViemSdk interface

<ResponseField name="deposits" type="DepositsResource">
  L1 → L2 flows (quote, prepare, create, status, wait). See <a href="/api-reference/viem/deposits">Deposits</a>.
</ResponseField>

<ResponseField name="withdrawals" type="WithdrawalsResource">
  L2 → L1 flows (quote, prepare, create, status, wait, finalize). See <a href="/api-reference/viem/withdrawals">Withdrawals</a>.
</ResponseField>

### `helpers`

Utilities for addresses, contracts, and token mapping.

#### `addresses() → Promise<ResolvedAddresses>`

Resolves core addresses (Bridgehub, routers, vaults, base token system).

```ts
const a = await sdk.helpers.addresses();
```

#### `contracts() → Promise<{ ...contracts }>`

Returns **typed viem contracts** for all core contracts (each exposes `.read` / `.write` / `.simulate`).

```ts
const c = await sdk.helpers.contracts();
const bridgehub = c.bridgehub;
```

#### `l1AssetRouter() / l1NativeTokenVault() / l1Nullifier()`

One-off getters if you only need a specific contract.

```ts
const nullifier = await sdk.helpers.l1Nullifier();
```

#### `baseToken(chainId?: bigint) → Promise<Address>`

L1 address of the base token for a given **L2 chain**. If omitted, uses the current L2 client’s chain id.

```ts
const base = await sdk.helpers.baseToken(); // infers from client.l2.getChainId()
```

#### `l2TokenAddress(l1Token: Address) → Promise<Address>`

Returns the **L2 token address** for a given **L1 token**.

* Handles ETH special-case (L2 ETH placeholder).
* If the token equals the chain’s base token, returns the L2 base-token system address.
* Otherwise queries `IL2NativeTokenVault.l2TokenAddress`.

```ts
const l2_crown_address = await sdk.helpers.l2TokenAddress(CROWN_ERC20_ADDRESS);
```

#### `l1TokenAddress(l2Token: Address) → Promise<Address>`

Returns the **L1 token address** from an **L2 token** using `IL2AssetRouter.l1TokenAddress`.

* ETH is treated as a special case.

```ts
const l1_crown_address = await sdk.helpers.l1TokenAddress(CROWN_ERC20_ADDRESS);
```

#### `assetId(l1Token: Address) → Promise<Hex>`

Computes the `bytes32` asset identifier for an L1 token via `L1NativeTokenVault.assetId`.

```ts
const id = await sdk.helpers.assetId(CROWN_ERC20_ADDRESS);
```

## Notes

* All results depend on the connected chains (L1/L2 RPCs) and any overrides supplied to the client.
* Errors surface as typed envelopes (see **Error Model** in API Reference intro). Prefer the <code>try*</code> variants on resources if you want result objects instead of exceptions.
