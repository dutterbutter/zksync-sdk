// scripts/emit-abi-ts.ts
// Usage: bun node scripts/emit-abi-ts.ts [SRC_DIR]
// Default SRC_DIR: src/core/internal/abis/json
//
// Reads *.json files, accepts either a plain ABI array or a { abi: [...] } artifact,
// and writes a sibling *.ts file exporting `<Name>ABI` as a readonly array.

import { promises as fs } from 'node:fs';
import path from 'node:path';
import url from 'node:url';

const SRC = process.argv[2] ?? 'src/core/internal/abis/json';

/** Turn "IERC20.json" → "IERC20" (safe TS identifier, no leading digits). */
function baseToIdentifier(base: string): string {
  const noExt = base.replace(/\.json$/i, '');
  const cleaned = noExt.replace(/[^a-zA-Z0-9_$]/g, '_');
  return /^[0-9]/.test(cleaned) ? `_${cleaned}` : cleaned;
}

/** Load JSON and normalize to an ABI array. Throws if not found/invalid. */
async function loadAbiArray(jsonPath: string): Promise<unknown[]> {
  const raw = await fs.readFile(jsonPath, 'utf8');
  let data: unknown;
  try {
    data = JSON.parse(raw);
  } catch (e) {
    throw new Error(`Invalid JSON: ${jsonPath}\n${(e as Error).message}`);
  }

  // Accept either a plain ABI array, or an artifact with an `abi` field
  const maybeArray = Array.isArray(data) ? data : (data as any)?.abi;
  if (!Array.isArray(maybeArray)) {
    throw new Error(
      `No ABI array found in: ${jsonPath} (expected an array or an object with "abi" array)`,
    );
  }
  return maybeArray;
}

/** Pretty-print JSON as TS literal (double quotes, 2-space indent). */
function toTsLiteral(value: unknown): string {
  // JSON.stringify keeps stable key ordering and escapes safely.
  // We rely on `as const` for readonly typing at the call site.
  return JSON.stringify(value, null, 2);
}

/** Emit a TS module with a named const and default export. */
function renderTsModule(varName: string, abiLiteral: string): string {
  // Intentionally no imports → agnostic of ethers/viem.
  // Consumers can derive their own types if needed:
  //   export type FooAbi = typeof FooABI;
  return `/* Autogenerated file. Do not edit manually. */
/* eslint-disable */
export const ${varName}ABI = ${abiLiteral} as const;

export default ${varName}ABI;
`;
}

async function main() {
  // Ensure directory exists
  const stat = await fs.stat(SRC).catch(() => null);
  if (!stat || !stat.isDirectory()) {
    throw new Error(`Source directory not found: ${path.resolve(SRC)}`);
  }

  const entries = await fs.readdir(SRC);
  const files = entries.filter((f) => f.toLowerCase().endsWith('.json'));

  if (files.length === 0) {
    console.warn(`No .json files found in ${SRC}`);
    return;
  }

  for (const file of files) {
    const jsonPath = path.join(SRC, file);
    const base = path.basename(file, '.json');
    const ident = baseToIdentifier(file);
    const tsPath = path.join(SRC, `${base}.ts`);

    try {
      const abi = await loadAbiArray(jsonPath);

      // Optional: light normalization — strip nulls/undefined to keep output tidy.
      const normalized = abi.map((item) => {
        if (item && typeof item === 'object') {
          const pruned: Record<string, unknown> = {};
          for (const [k, v] of Object.entries(item as Record<string, unknown>)) {
            if (v !== null && v !== undefined) pruned[k] = v;
          }
          return pruned;
        }
        return item;
      });

      const content = renderTsModule(ident, toTsLiteral(normalized));
      await fs.writeFile(tsPath, content, 'utf8');
      console.log('wrote', path.relative(process.cwd(), tsPath));
    } catch (err) {
      console.error(`Failed to process ${jsonPath}:`, (err as Error).message);
      // Continue processing the rest instead of aborting the whole run.
    }
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
